# This is part 2 of a code-clean version of the project:
# https://www.kaggle.com/czz1403/dm13-1204880-python
# original report written in Chinese

# %% packages & filter warnings

import re
import numpy as np
import pandas as pd
import warnings
import matplotlib.pyplot as plt
import seaborn as sns

warnings.filterwarnings('ignore')

# %% load data using csv files generated by part 1
# files are generated after running 01_data_collection.py under the same path

data_04 = pd.read_csv("./2004.csv")
data_06 = pd.read_csv("./2006.csv")
data_08 = pd.read_csv("./2008.csv")
data_11 = pd.read_csv("./2011.csv")
rd_dict = pd.read_csv("./ridings.csv").set_index('Code').to_dict()['2011 Ridings']

# %% major party vote count by prov/terr dfs
# created for each election year

ptdt_04 = data_04.iloc[:, 1:].groupby(by='Province').sum()
ptdt_06 = data_06.iloc[:, 1:].groupby(by='Province').sum()
ptdt_08 = data_08.iloc[:, 1:].groupby(by='Province').sum()
ptdt_11 = data_11.iloc[:, 1:].groupby(by='Province').sum()

# %% 4 years party-prov/terr vote count sum up dataframe

# summarizing counts
can_total = pd.DataFrame(ptdt_04.sum().rename('2004'))
can_total['2006'] = ptdt_06.sum()
can_total['2008'] = ptdt_08.sum()
can_total['2011'] = ptdt_11.sum()
can_total = can_total.T
can_total.index = can_total.index.rename('Year')
can_total = can_total.reset_index()

# adding percentages
can_total['LIB %'] = can_total['Liberal'] / can_total['Total Votes']
can_total['CON %'] = can_total['Conservative'] / can_total['Total Votes']
can_total['NDP %'] = can_total['NDP'] / can_total['Total Votes']
can_total['BLQ %'] = can_total['BQ'] / can_total['Total Votes']
can_total['OTH %'] = can_total['Others'] / can_total['Total Votes']

# %% visualizing the vote percentages grabbed by major parties

parties = ['Liberal', 'Conservative', 'NDP', 'BQ', 'Others']
pct_list = ['LIB %', 'CON %', 'NDP %', 'BLQ %', 'OTH %']
colors = ['red', 'blue', 'orange', 'turquoise', 'grey']  # representative colors for parties (and "others")

fig, ax1 = plt.subplots(figsize=(8, 9))

annotate_list = []

# line graph & shades
for i in range(5):

    ax1.plot(
        can_total['Year'],
        can_total[pct_list[i]],
        label=parties[i],
        color=colors[i]
    )

    ax1.fill_between(
        can_total['Year'],
        can_total[pct_list[i]],
        label=None,
        color=colors[i],
        alpha=0.1,
    )

    for index, percent in zip(can_total.index, can_total[pct_list[i]]):
        annotate_list.append((index, percent))

# percentage notes
for x, y in annotate_list:

    ax1.annotate(
        '{:.1%}'.format(y),
        xy=(x, y),
        xytext=(float(x), y+0.01),
        ha="center",
    )

ax1.set_ylim(0, 0.5)
plt.legend(loc=2)

plt.vlines(
    [0, 1, 2, 3],
    0,
    .5,
    linestyles='dashed',
    alpha=0.05,
) # vertical lines

plt.yticks(
    ticks=np.arange(0, .6, .1),
    labels=['{:.1%}'.format(p) for p in np.arange(0, .6, .1)],
)
plt.show()

# %% count of seats won by parties dataframe

elected_df = pd.DataFrame(
    [
        data_04['Elected'].value_counts().rename('2004'),
        data_06['Elected'].value_counts().rename('2006'),
        data_08['Elected'].value_counts().rename('2008'),
        data_11['Elected'].value_counts().rename('2011')
    ],
)[parties]

# %% count of seats won by parties each year visualization

fig, ax2 = plt.subplots(figsize=(7, 8))

# plot stacked bars
plt.bar(elected_df.index, elected_df[parties[0]], color=colors[0], width=0.5)

for i in range(5):

    plt.bar(
        elected_df.index, elected_df[parties[i]],
        bottom=elected_df.iloc[:,:i].sum(axis=1),
        color=colors[i],
        width=0.5,
    )

# annotate the counts
for i in range(4):
    for j in range(4):
        if i==3 and j==3: # special case for BQ in 2011
            ax2.annotate(
                4,
                xy = (3, 305),
                xytext = (3, 300),
                ha="center",
                color="white",
                fontsize="medium",
            )
        else:
            ax2.annotate(
                elected_df.iloc[i, j],
                xy = (i, (elected_df.iloc[:,:j].sum(axis=1) + elected_df.iloc[:,:j+1].sum(axis=1)).tolist()[i] / 2),
                ha="center",
                color="white",
                fontsize="medium",
            )

ax2.set_ylim(0, 308) # ylim

plt.xlabel('Year')
plt.ylabel('Seat Count')
plt.yticks(range(0, 310, 77)) # set yticks
plt.show()

# %% vote count plotting by year and prov/terr, bar chart
# this chart is good for general comparison yet unclear for prov/terr with small populations

ptdt_list = [ptdt_04, ptdt_06, ptdt_08, ptdt_11]
prov_list = [
    'BC',
    'AB',
    'SK',
    'MB',
    'ON',
    'QC',
    'NB',
    'PE',
    'NS',
    'NL',
    'Territories',
] # rearrange prov/terr by geographical locations
year_list = ['2004', '2006', '2008', '2010']

fig, axes = plt.subplots(nrows=4, ncols=1, figsize=(14, 20))

plt.setp(axes, ylim=[0, 2700000])

for i in range(4):

    ptdt_list[i][parties].loc[prov_list].plot.bar(color=colors, ax=axes[i])
    axes[i].set_xticklabels(prov_list, rotation=0)

    axes[i].set_title(f"{year_list[i]} Canadian General Election Vote Distribution by Provinces / Territories")

# %% 2004 party vote counts & percentages by prov/terr, pie chart
# shows situation with each prov/terr much clearer
# prototype of such type of graph. Only repeated for 2 election years in the original report for not overloading it
# can be repeated for the other 2 election years as a matter of fact

fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(20, 15))

parties_nonBQ = ['Liberal', 'Conservative', 'NDP', 'Others']
colors_nonBQ = ['red', 'blue', 'orange', 'grey']

# a pie for each prov / all terr
for i in range(11):

    if i == 5: # Bloc runs in Quebec
        partylist = parties
        clist = colors
    else: # Bloc not running in other prov/terr
        partylist = parties_nonBQ
        clist = colors_nonBQ

    vote_counts = ptdt_04.loc[prov_list[i]][partylist].tolist()
    total = ptdt_04['Total Votes'].loc[prov_list[i]]

    # pie & labeling
    axes[i//4, i%4].pie(
        vote_counts,
        colors=clist,
        labels=[f'{partylist[j]}\n{int(vote_counts[j])} - '+'{:.1%}'.format(vote_counts[j]/total)\
                for j in range(len(vote_counts))],
        labeldistance=0.8,
        startangle=-5,
        radius=np.log10(np.cbrt(total/2000)),
    )

    # subplot title
    axes[i//4, i%4].set_title(f'{prov_list[i]} - {total} votes total')

fig.suptitle('2004 Canadian General Election Vote Counts and Distributions by Provinces / Territories')
plt.axis('off') # hide the axis of unused 12th subplot
plt.show()

# %% 2011 party vote counts & percentages by prov/terr, pie chart
# same prototype with 2004 charting
# only repeated for 2 election years in the original report for not overloading it
# can be repeated for the other 2 election years as a matter of fact

fig, axes = plt.subplots(nrows=3, ncols=4, figsize=(20, 15))

for i in range(11):

    if i == 5:
        partylist = parties
        clist = colors
    else:
        partylist = parties_nonBQ
        clist = colors_nonBQ

    vote_counts = ptdt_11.loc[prov_list[i]][partylist].tolist()
    total = ptdt_11['Total Votes'].loc[prov_list[i]]

    axes[i//4, i%4].pie(
        vote_counts,
        colors=clist,
        labels=[f'{partylist[j]}\n{int(vote_counts[j])} - '+'{:.1%}'.format(vote_counts[j]/total)\
                for j in range(len(vote_counts))],
        labeldistance=0.79,
        startangle=10,
        radius=np.log10(np.cbrt(total/2000)),
    )
    axes[i//4, i%4].set_title(f'{prov_list[i]} - {total} votes total')

fig.suptitle('2011 Canadian General Election Vote Counts and Distributions by Provinces / Territories')
plt.axis('off')
plt.show()

# %% parties gaining / losing EDs count visualization

elected_sum = pd.DataFrame(
    [elected_df.iloc[i] - elected_df.iloc[i-1] for i in range(1, 4)],
    index=['04 to 06', '06 to 08', '08 to 11'],
)

fig, ax = plt.subplots(figsize=(4, 7))

ax.set_ylim((-70, 70))
ax.set_yticklabels(["-80", "-60", "-40", "-20", "0", "+20", "+40", "+60"])

elected_sum.plot.bar(color=colors, ax=ax)

ax.hlines(0, -1, 4)
ax.hlines(
    [20, 40, 60, -20, -40, -60],
    -1,
    5,
    linestyles='dashed',
    alpha=0.1
)

plt.show()

# %% EDs by winning parties and election years summarizing dataframe

rd_data = data_04[['District', 'Province']]

party_dict = {
    'Liberal': 'LIB',
    'Conservative': 'CON',
    'NDP': 'NDP',
    'BQ': 'BLQ',
    'Others': 'OTH'
} # 3 letter abbreviations for all parties (and "others")

rd_data['04 Elected'] = data_04['Elected'].map(party_dict)
rd_data['06 Elected'] = data_06['Elected'].map(party_dict)
rd_data['08 Elected'] = data_08['Elected'].map(party_dict)
rd_data['11 Elected'] = data_11['Elected'].map(party_dict)

# %% adding ED gaining or flipping data

chg_0406 = []
chg_0608 = []
chg_0811 = []

for i in range(len(rd_data)):

    if rd_data['06 Elected'].iloc[i] == rd_data['04 Elected'].iloc[i]:
        chg_0406.append(rd_data['06 Elected'].iloc[i] + " holds")
    else:
        chg_0406.append(rd_data['04 Elected'].iloc[i] + " flip to " + rd_data['06 Elected'].iloc[i])

for j in range(len(rd_data)):

    if rd_data['08 Elected'].iloc[j] == rd_data['06 Elected'].iloc[j]:
        chg_0608.append(rd_data['08 Elected'].iloc[j] + " holds")
    else:
        chg_0608.append(rd_data['06 Elected'].iloc[j] + " flip to " + rd_data['08 Elected'].iloc[j])

for k in range(len(rd_data)):

    if rd_data['11 Elected'].iloc[k] == rd_data['08 Elected'].iloc[k]:
        chg_0811.append(rd_data['11 Elected'].iloc[k] + " holds")
    else:
        chg_0811.append(rd_data['08 Elected'].iloc[k] + " flip to " + rd_data['11 Elected'].iloc[k])

rd_data['04 to 06'] = chg_0406
rd_data['06 to 08'] = chg_0608
rd_data['08 to 11'] = chg_0811

rd_data # examine the result

# %% 2008 to 2011 transition data frame
# prototype for 3 potential transition data frames
# only completed 1 in original report for not overloading the report
# data processing and analysis could all be repeated for 04-06 and 06-08 transitions

df_0811 = rd_data[['District', 'Province', '08 Elected', '11 Elected', '08 to 11']]

# dividing holds ridings and flip ridings
hd_0811 = df_0811[df_0811['08 to 11'].str.contains('holds')]
fp_0811 = df_0811[df_0811['08 to 11'].str.contains('flip')]

# %% flipping count by prov/terr visualization

fpcount = fp_0811['Province'].value_counts()

plt.bar(fpcount.index, fpcount.values)
plt.show()

# %% flipping ED percentages by prov/terr visualization
# shows the proportion of EDs being flipped in 2011 election

fptotal = df_0811['Province'].value_counts()
rates = []

for pt in fptotal.index:

    try:
        rates.append(fpcount[pt] / fptotal[pt])
    except:
        rates.append(0) # 3 provinces didn't have any ED flipped in 2011 election, as show by previous graph

fprate = pd.Series(rates)
fprate.index = fptotal.index

plt.bar(fprate.index, fprate.values)
plt.yticks(
    ticks=np.arange(0, .9, .1),
    labels=['{:.1%}'.format(p) for p in np.arange(0, .9, .1)],
)
plt.hlines([0.2, 0.4, 0.6], 0, 11, linestyles='solid', alpha=0.1)
plt.show()

# %% analysis of Qubec 2011 flipped ED - case count

# Quebec data
qc_0811 = fp_0811[fp_0811['Province']=='QC']

sns.countplot(qc_0811['08 to 11'])

# %% analysis of conservative party taking over
# Conservative Party of Canada advanced from minority government to majority government in 2011 election
# exploring at which provinces had CPC gained in 2011

# conservative data
con_0811 = fp_0811[fp_0811['11 Elected']=='CON']

con_0811['Province'].value_counts()

# %% take a peek at Ontario 2011 to-conservative flips
# count in previous cell shows that most of conservative gain in 2011 took place in Ontario

con_0811[con_0811['Province'] == 'ON'] # notice the "08 to 11" column

# %% flipped riding names
# demonstrate the usage of ED code/name dict

con_0811[con_0811['Province'] == 'ON']['District'].map(rd_dict)

# %% 2008 to 2011 flips - count by case chart

fig, ax = plt.subplots(figsize=(8, 5))

sns.countplot(fp_0811['08 to 11'], ax=ax)
ax.set_xticklabels(labels=fp_0811['08 to 11'].unique().tolist(), rotation=90)
plt.show()

# %% three flip-less provinces situation
# an example of potential functions of hold EDs dataframe

hd_0811[hd_0811['Province'].isin(['PE', 'SK', 'AB'])]

# %% inter-election gains and flips - heatmap - prepare pivot table
# use heatmap to sum up all loss and gains of seats for major parties

# pivoting functions
def making_pivot(yA,yB):

    count = []

    for pa in list(party_dict.values()):
        for pb in list(party_dict.values()):
            count.append([
                pa,
                pb,
                len(rd_data[rd_data[f'{yA} Elected']==pa].loc[rd_data[f'{yB} Elected'] == pb])
            ])

    df = pd.DataFrame(count)
    df.columns = [f'{yA} Elected', f'{yB} Elected', 'Count']
    df = df.pivot_table(
        values='Count',
        index=f'{yA} Elected',
        columns=f'{yB} Elected',
        aggfunc=np.mean
    )

    return df

# make pivot tables for all three inter-election instances
count_0406 = making_pivot('04', '06')
count_0608 = making_pivot('06', '08')
count_0811 = making_pivot('08', '11')

# %% inter-election gains and flips - heatmap illustration

fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(18, 6))

pivot_list = [count_0406, count_0608, count_0811]

for i in range(3):
    sns.heatmap(
        pivot_list[i],
        ax = ax[i],
        cmap='PuOr',
        annot=True,
        fmt='g',
        square=True,
    )

fig.suptitle("Gains & Losses Count of Major Parties, 2006, 2008 & 2011 Elections")
plt.show()

# %% Count the hold/flip figures for each ED
# for each ED, counts:
# - accumulated number of different parties (including "others") elected in that ED
# - accumulated times of getting flipped

pt_count=[]
fp_count = []

for i in range(len(rd_data)):

    pt_count.append(len(
        rd_data[['04 Elected', '06 Elected', '08 Elected', '11 Elected']].iloc[i].unique()
    ))

    count = 0

    for j in range(3):
        if 'flip' in rd_data.iloc[i, -j-1]:
            count += 1

    fp_count.append(count)

rd_data['Party Count'] = pt_count
rd_data['Flip Count'] = fp_count

# %% most flipped EDs between 2004 and 2011

rd_data.loc[rd_data['Flip Count'] == rd_data['Flip Count'].max()]

# %% most flipped ED names

rd_data.loc[rd_data['Flip Count'] == rd_data['Flip Count'].max()]['District'].map(rd_dict)

# %% EDs that has supported greatest number of different parties

rd_data.loc[rd_data['Party Count'] == rd_data['Party Count'].max()]

# %% EDs that has supported all of the 3 major parties
# major 3: Conservative, Liberal, New Democratic Party

rd_data.loc[rd_data['Party Count'] == 3].replace('BLQ', np.nan).replace('OTH', np.nan).dropna()
# %% names of EDs that has supported all of the 3 major parties

rd_data.loc[rd_data['Party Count'] == 3].replace('BLQ', np.nan).replace('OTH', np.nan).dropna()['District'].map(rd_dict)
# %%
